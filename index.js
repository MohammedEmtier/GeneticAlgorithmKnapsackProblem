const { Random } = require('random-js');
const random = new Random(); // Random number generator

// Genetic algorithm Parameters
const POPULATION_SIZE = 100;
const MUTATION_RATE = 0.1;
const MAX_GENERATIONS = 100;

// Knapsack Problem parameters
const items = [
    { weight: 2, value: 5 },
    { weight: 3, value: 8 },
    { weight: 5, value: 13 },
    { weight: 7, value: 20 },
    { weight: 9, value: 25 }
];
const knapsackCapacity = 15;

function fitness(individual) {
    // Evaluate the fitness of an individual based on the Knapsack Problem
    let totalValue = 0;
    let totalWeight = 0;
    for (let i = 0; i < individual.length; i++) {
        if (individual[i]) {
            totalValue += items[i].value;
            totalWeight += items[i].weight;
        }
    }
    // Return the total value of the selected items if the total weight doesnt exceed the capacity
    return totalWeight <= knapsackCapacity ? totalValue : 0;
}

function crossover(parent1, parent2) {
    // one-point crossover between two parents
    const crossoverPoint = random.integer(1, items.length - 1);
    const child1 = parent1.slice(0, crossoverPoint).concat(parent2.slice(crossoverPoint));
    const child2 = parent2.slice(0, crossoverPoint).concat(parent1.slice(crossoverPoint));
    // Return the offspring generated by exchanging genetic material
    return [child1, child2];
}

function mutate(individual) {
    // Apply mutation on an individual
    // Flip the bit of a randomly selected item with the mutation rate
    for (let i = 0; i < individual.length; i++) {
        if (random.real(0, 1) < MUTATION_RATE) {
            individual[i] = individual[i] ? 0 : 1;
        }
    }
}

function createIndividual() {
    // Generate a random individual
    return Array.from({ length: items.length }, () => random.bool() ? 1 : 0);
}

// Initialization
let population = Array.from({ length: POPULATION_SIZE }, createIndividual);

// Main loop
// should it be a loop or recursive function ?
// may be recursive function is better to simulate the process, but we keep the implementation a bit simple
let generation = 1;
let previousMaxFitness = 0;
let generationsWithoutImprovement = 0;
let fitnessScores;

while (generation <= MAX_GENERATIONS && generationsWithoutImprovement < 10) {
    // Evaluation
    fitnessScores = population.map(fitness);

    // Selection, tournament
    const selectedParents = tournamentSelection(population, fitnessScores);

    // Reproduction ( Crossover and Mutation )
    const offspring = [];
    for (let i = 0; i < selectedParents.length; i += 2) {
        const [child1, child2] = crossover(selectedParents[i], selectedParents[i + 1]);
        mutate(child1);
        mutate(child2);
        offspring.push(child1, child2);
    }

    // Replacement
    population = offspring;

    // Convergence check
    const maxFitness = Math.max(...fitnessScores);
    if (maxFitness === previousMaxFitness) {
        generationsWithoutImprovement++;
    } else {
        generationsWithoutImprovement = 0;
    }
    previousMaxFitness = maxFitness;

    generation++;
}
function tournamentSelection(population, fitnessScores, tournamentSize = 2) {
    const selectedParents = [];
    for (let i = 0; i < population.length; i++) {
        const competitors = random.sample(population, tournamentSize);
        const competitorsFitness = competitors.map((individual) => fitnessScores[population.indexOf(individual)]);
        const bestCompetitor = competitors[competitorsFitness.indexOf(Math.max(...competitorsFitness))];
        selectedParents.push(bestCompetitor);
    }
    return selectedParents;
}

// Print the best individual found
const bestFitnessIndex = fitnessScores.indexOf(Math.max(...fitnessScores));
const bestIndividual = population[bestFitnessIndex];
console.log("Best Individual:", bestIndividual);
console.log("Fitness:", fitnessScores[bestFitnessIndex]);
